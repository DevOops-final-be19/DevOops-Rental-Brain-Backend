<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.devoops.rentalbrain.customer.segment.query.mapper.SegmentQueryMapper">

    <!-- 세그먼트 목록 조회 -->
    <resultMap id="SegmentQueryListMap" type="com.devoops.rentalbrain.customer.segment.query.dto.SegmentQueryListDTO">
        <id property="segmentId" column="SEGMENT_ID"/>
        <result property="segmentName" column="SEGMENT_NAME"/>
        <result property="segmentContent" column="SEGMENT_CONTENT"/>
    </resultMap>
    <select id="selectSegmentList" resultMap="SegmentQueryListMap">
        SELECT
               A.ID   AS SEGMENT_ID
             , A.NAME AS SEGMENT_NAME
             , A.CONTENT AS SEGMENT_CONTENT
         FROM SEGMENT A
         WHERE (#{segmentName} IS NULL OR A.NAME LIKE CONCAT('%', #{segmentName}, '%'))
    </select>



    <!--  세그먼트 단건(detail) 조회  -->
    <resultMap id="SegmentQueryDetailMap" type="com.devoops.rentalbrain.customer.segment.query.dto.SegmentQueryDetailDTO">
        <id property="segmentId" column="SEGMENT_ID"/>
        <result property="segmentName" column="SEGMENT_NAME"/>
        <result property="segmentContent" column="SEGMENT_CONTENT"/>
        <result property="segmentTotalCharge" column="SEGMENT_TOTAL_CHARGE"/>
        <result property="segmentPeriod" column="SEGMENT_PERIOD"/>
        <result property="segmentIsContracted" column="SEGMENT_IS_CONTRACTED"/>
        <result property="segmentOverdued" column="SEGMENT_OVERDUED"/>

        <!-- 고객 리스트 -->
        <collection property="customers"
                    ofType="com.devoops.rentalbrain.customer.segment.query.dto.SegmentQueryDetailDTO$SegmentCustomerDTO"
                    column="SEGMENT_ID"
                    select="selectCustomersBySegmentId"/>

    </resultMap>

    <!-- 세그먼트 단건 조회(세그먼트만 상세 조회) -->
    <select id="selectSegmentDetail" resultMap="SegmentQueryDetailMap">
        SELECT
               A.ID   AS SEGMENT_ID
             , A.NAME AS SEGMENT_NAME
             , A.CONTENT AS SEGMENT_CONTENT
             , A.TOTAL_CHARGE AS SEGMENT_TOTAL_CHARGE
             , A.SEGMENT_PERIOD AS SEGMENT_PERIOD
             , A.IS_CONTRACTED AS SEGMENT_IS_CONTRACTED
             , A.OVERDUED AS SEGMENT_OVERDUED
        FROM SEGMENT A
        WHERE A.ID = #{segmentId}
    </select>

    <!-- ✅ 세그먼트에 속한 고객 목록 -->
    <select id="selectCustomersBySegmentId"
            resultType="com.devoops.rentalbrain.customer.segment.query.dto.SegmentQueryDetailDTO$SegmentCustomerDTO">
        SELECT
               A.ID            AS customerId
             , A.CUSTOMER_CODE AS customerCode
             , A.NAME          AS customerName
             , A.IN_CHARGE     AS inCharge
             , A.DEPT          AS dept
             , A.CALL_NUM      AS callNum
             , A.STAR          AS star
             , A.IS_DELETED    AS isDeleted
        FROM CUSTOMER A
        WHERE A.SEGMENT_ID = #{segmentId}
          AND A.IS_DELETED = 'N'
        ORDER BY A.ID DESC
    </select>

    <!-- 세그먼트 분석 KPI 목록 조회 - 공부중 -->
    <select id="selectSegmentKpi"
            resultType="com.devoops.rentalbrain.customer.segment.query.dto.SegmentQueryKPIDTO">

        WITH
            total AS (
                SELECT COUNT(*) AS totalCustomerCount
                FROM customer
                WHERE is_deleted = 'N'
            ),
            risk AS (
                SELECT COUNT(*) AS riskCustomerCount
                FROM customer c
                         JOIN segment s ON s.id = c.segment_id
                WHERE c.is_deleted = 'N'
                  AND s.name = #{riskSegmentName}
            ),
            low_this AS (
                SELECT COUNT(DISTINCT f.cum_id) AS lowCntThis
                FROM feedback f
                         JOIN customer c ON c.id = f.cum_id
                WHERE c.is_deleted = 'N'
                  AND f.create_date BETWEEN #{monthStart} AND #{monthEnd}
                  AND f.star &lt; #{lowStar}
            ),
            low_prev AS (
                SELECT COUNT(DISTINCT f.cum_id) AS lowCntPrev
                FROM feedback f
                         JOIN customer c ON c.id = f.cum_id
                WHERE c.is_deleted = 'N'
                  AND f.create_date BETWEEN #{prevStart} AND #{prevEnd}
                  AND f.star &lt; #{lowStar}
            )

        SELECT
            /* ① 이탈 위험 고객 비중 */
            ROUND(
                    (risk.riskCustomerCount * 1.0 / total.totalCustomerCount) * 100
                , 1) AS riskCustomerRate,
            risk.riskCustomerCount AS riskCustomerCount,
            total.totalCustomerCount AS totalCustomerCount,

            /* ② 전월 대비 변화 */
            ROUND(
                    ((low_this.lowCntThis * 1.0 / total.totalCustomerCount) * 100)
                        - ((low_prev.lowCntPrev * 1.0 / total.totalCustomerCount) * 100)
                , 1) AS momChangeRate,

            /* ③ 가장 위험한 세그먼트 */
            rs.mostRiskySegmentName,
            rs.mostRiskySegmentRate,

            /* ④ 최저 만족도 세그먼트 */
            ls.lowestSatisfactionSegmentName,
            ls.lowestSatisfactionAvgStar

        FROM total
                 CROSS JOIN risk
                 CROSS JOIN low_this
                 CROSS JOIN low_prev

                 LEFT JOIN (
            SELECT
                s.name AS mostRiskySegmentName,
                ROUND(
                        (COUNT(DISTINCT CASE
                                            WHEN f.star &lt; #{lowStar} THEN c.id
                            END) * 1.0 / COUNT(DISTINCT c.id)) * 100
                    , 1) AS mostRiskySegmentRate
            FROM segment s
                     JOIN customer c
                          ON c.segment_id = s.id
                              AND c.is_deleted = 'N'
                     LEFT JOIN feedback f
                               ON f.cum_id = c.id
                                   AND f.create_date BETWEEN #{monthStart} AND #{monthEnd}
            GROUP BY s.id, s.name
            HAVING COUNT(DISTINCT c.id) > 0
            ORDER BY mostRiskySegmentRate DESC
                LIMIT 1
        ) rs ON 1=1

                 LEFT JOIN (
            SELECT
                s.name AS lowestSatisfactionSegmentName,
                ROUND(AVG(f.star), 1) AS lowestSatisfactionAvgStar
            FROM segment s
                     JOIN customer c
                          ON c.segment_id = s.id
                              AND c.is_deleted = 'N'
                     JOIN feedback f
                          ON f.cum_id = c.id
                              AND f.create_date BETWEEN #{monthStart} AND #{monthEnd}
            GROUP BY s.id, s.name
            ORDER BY lowestSatisfactionAvgStar ASC
                LIMIT 1
        ) ls ON 1=1

    </select>
</mapper>